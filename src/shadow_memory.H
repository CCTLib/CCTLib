// @COPYRIGHT@
// Licensed under MIT license.
// See LICENSE.TXT file in the project root for more information.
// ==============================================================
#ifndef __SHADOW_MEMORY__
#define __SHADOW_MEMORY__
#include<stdint.h>
#include<atomic>
#include<stdlib.h>
#include<sys/mman.h>

// 64KB shadow pages
#define PAGE_OFFSET_BITS (16LL)
#define PAGE_OFFSET(addr) ( addr & 0xFFFF)
#define PAGE_OFFSET_MASK ( 0xFFFF)
#define SHADOW_PAGE_SIZE (1 << PAGE_OFFSET_BITS)

// 2 level page table
#define PTR_SIZE (sizeof(struct Status *))
#define LEVEL_1_PAGE_TABLE_BITS  (20)
#define LEVEL_1_PAGE_TABLE_ENTRIES  (1 << LEVEL_1_PAGE_TABLE_BITS )
#define LEVEL_1_PAGE_TABLE_SIZE  (LEVEL_1_PAGE_TABLE_ENTRIES * PTR_SIZE )

#define LEVEL_2_PAGE_TABLE_BITS  (12)
#define LEVEL_2_PAGE_TABLE_ENTRIES  (1 << LEVEL_2_PAGE_TABLE_BITS )
#define LEVEL_2_PAGE_TABLE_SIZE  (LEVEL_2_PAGE_TABLE_ENTRIES * PTR_SIZE )

#define LEVEL_1_PAGE_TABLE_SLOT(addr) ((((uint64_t)addr) >> (LEVEL_2_PAGE_TABLE_BITS + PAGE_OFFSET_BITS)) & 0xfffff)
#define LEVEL_2_PAGE_TABLE_SLOT(addr) ((((uint64_t)addr) >> (PAGE_OFFSET_BITS)) & 0xFFF)

#define SHADOW_STRUCT_SIZE (sizeof (T))
using namespace std;

template <class T>
class ConcurrentShadowMemory {
    // All fwd declarations
    atomic< atomic<T *> *> * pageDirectory;
    // Given a address generated by the program, returns the corresponding shadow address FLOORED to  SHADOW_PAGE_SIZE
    // If the shadow page does not exist a new one is MMAPed
public:
    inline ConcurrentShadowMemory() {
       pageDirectory = (atomic< atomic<T *> *> *) mmap(0, LEVEL_1_PAGE_TABLE_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
      if(pageDirectory == MAP_FAILED) {
          perror("mmap pageDirectory");
          PIN_ExitProcess(-1);
      }
    }

    inline ~ConcurrentShadowMemory(){
        for(uint64_t i = 0; i < LEVEL_1_PAGE_TABLE_ENTRIES; i++) {
            atomic<T*> * l1Page;
            if( (l1Page=pageDirectory[i].load(memory_order_relaxed)) != 0) {
                for(uint64_t j = 0; j < LEVEL_2_PAGE_TABLE_ENTRIES; j++) {
                    T * l2Page;
                    if( (l2Page=l1Page[j].load(memory_order_relaxed)) != 0){
                        if(0 != munmap(l2Page, SHADOW_PAGE_SIZE * SHADOW_STRUCT_SIZE))
                            perror("munmap");
                    }
                } 
            }
        }
    }

    inline T * GetOrCreateShadowBaseAddress(const size_t address) {
        atomic< atomic<T *> *>  * l1Ptr = & pageDirectory[LEVEL_1_PAGE_TABLE_SLOT(address)];
        atomic<T *> * v1;
        if ( (v1=l1Ptr->load(memory_order_consume)) == 0) {
            atomic<T *> * l1pg = (atomic<T *> *) mmap(0, LEVEL_2_PAGE_TABLE_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
            if(l1pg == MAP_FAILED) {
              perror("mmap l1pg");
              PIN_ExitProcess(-1);
            }

            atomic<T *> * nullVal = 0;
            if(!l1Ptr->compare_exchange_strong(nullVal, l1pg, memory_order_acq_rel, memory_order_relaxed)) {
                free(l1pg);
                v1 = l1Ptr->load(memory_order_consume);
            } else {
                v1 = l1pg;
            }
        } 
        atomic<T *>  * l2Ptr = & v1[LEVEL_2_PAGE_TABLE_SLOT(address)];
        T * v2;
        if( (v2=l2Ptr->load(memory_order_consume)) == 0 ){
                T * l2pg = (T *) mmap(0, SHADOW_PAGE_SIZE * SHADOW_STRUCT_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
                if(l2pg == MAP_FAILED) {
                  perror("mmap l2pg");
                  PIN_ExitProcess(-1);
                }
                T * nullVal = 0;
                if( !l2Ptr->compare_exchange_strong(nullVal, l2pg, memory_order_acq_rel, memory_order_relaxed)){
                    munmap(l2pg, SHADOW_PAGE_SIZE * SHADOW_STRUCT_SIZE);
		    v2 = l2Ptr->load(memory_order_consume);
		} else {
                    v2 = l2pg;
		}
        } 
        return v2;
    }
    
    inline T * GetOrCreateShadowAddress(const size_t address) {
        T * shadowPage = GetOrCreateShadowBaseAddress(address);
        return shadowPage + PAGE_OFFSET((uint64_t)address);
    }
};

template <class T>
class ShadowMemory {
    // All fwd declarations
    T *** pageDirectory;
    // Given a address generated by the program, returns the corresponding shadow address FLOORED to  SHADOW_PAGE_SIZE
    // If the shadow page does not exist a new one is MMAPed
public:
    inline ShadowMemory() {
       pageDirectory = (atomic< atomic<T *> *> *) mmap(0, LEVEL_1_PAGE_TABLE_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
      if(pageDirectory == MAP_FAILED) {
          perror("mmap pageDirectory");
          PIN_ExitProcess(-1);
      }
    }

    inline ~ShadowMemory(){
        for(uint64_t i = 0; i < LEVEL_1_PAGE_TABLE_ENTRIES; i++) {
            atomic<T*> * l1Page;
            if( (l1Page=pageDirectory[i].load(memory_order_relaxed)) != 0) {
                for(uint64_t j = 0; j < LEVEL_2_PAGE_TABLE_ENTRIES; j++) {
                    T * l2Page;
                    if( (l2Page=l1Page[j].load(memory_order_relaxed)) != 0){
                        if(0 != munmap(l2Page, SHADOW_PAGE_SIZE * SHADOW_STRUCT_SIZE))
                            perror("munmap");
                    }
                } 
            }
        }
    }


    inline T * GetOrCreateShadowBaseAddress(const size_t address) {
        T *** l1Ptr = & pageDirectory[LEVEL_1_PAGE_TABLE_SLOT(address)];
        T ** v1;
        if ( (v1=*l1Ptr) == 0) {
            T ** l1pg = (T **) mmap(0, LEVEL_2_PAGE_TABLE_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
            if(l1pg == MAP_FAILED) {
              perror("mmap l1pg");
              PIN_ExitProcess(-1);
            }
            v1 = l1pg;
        } 
        T ** l2Ptr = & v1[LEVEL_2_PAGE_TABLE_SLOT(address)];
        T * v2;
        if( (v2=*l2Ptr) == 0 ){
                T * l2pg = (T *) mmap(0, SHADOW_PAGE_SIZE * SHADOW_STRUCT_SIZE, PROT_WRITE | PROT_READ, MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);
                if(l2pg == MAP_FAILED) {
                  perror("mmap l2pg");
                  PIN_ExitProcess(-1);
                }
                v2 = l2pg;
        } 
        return v2;
    }
    
    inline T * GetOrCreateShadowAddress(const size_t address) {
        T * shadowPage = GetOrCreateShadowBaseAddress(address);
        return shadowPage + PAGE_OFFSET((uint64_t)address);
    }
};

#if 0
ShadowMemory<int> i;
int main(){

i.GetOrCreateShadowAddress(0x12345678)[0] = 1234;
int j = i.GetOrCreateShadowAddress(0x12345678)[0];
return 0;
}
#endif

#endif // __SHADOW_MEMORY__
